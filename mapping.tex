\chapter{Mapping Techniques for SDOG and the Extension Method} \label{chap:mapping}





\subsection{SDOG Indexing} \label{sec:sdog-indexing}
In order to identify and distinguish the cells of a grid, there needs to be a method to assign a unique index to each cell.
A good indexing scheme will allow for efficient data insertion, retrieval, and manipulation via a set of queries.
Examples of some of these queries are: point to cell, which give the index of the cell containing a given point; index inversion, which calculates a cell's location and geometry from the index; neighbourhood queries; and in the case of a hierarchical grid, hierarchy traversal to find parent and children cells.


Due to the fact that SDOG refinement is based on the midpoints of spherical coordinates, an indexing scheme that is efficient for many of the above operations can be easily developed.
At any refinement level, $k$, each cell can be given an integer index in each spherical coordinate ranging from zero to $2^{k} - 1$.
To address the degenerate refinement of certain cells, these integer indices are modified appropriately with divisions by powers of two, which can be done quickly with bit shift operations.
The integer indices can then be linearized by various methods, one good choice being a Z-order curve \cite{morton1966computer} as used in \cite{yu2009sdog}.
A more detailed description of degenerate Z-order indexing for SDOG grids, including algorithms for point to cell and index inversion operations, can be found in \cite{yu2009coding}.


\section{Radial Mappings}
In these mappings, we use $\hat{r}$ to refer to a radius $r$ normalized to the range of the grid ($r/R_\mathrm{max}$).

Referring to Figure~\ref{fig:central-split}, we see that the radial splits for central layers divide the grid into regions representing spherical shells.
We also note that each of these shells contains a different number of cells.
More specifically, shell $n$ has a value of $k_s$ one greater than that of shell $n+1$, and therefore as refinement continues, we expect shell $n$ to contain $f^3$ times as many cells.
Ideally, then, shell $n$ will represent a region with $f^3$ times the volume as well.
To accomplish this, we can define a radial mapping that maps radial splits in the grid to corresponding radial splits that result in the appropriate volume.
We summarize the method below, with more details available in~\cite{ulmertoward2020}.
The volume shell $n$ represents is proportional to


\begin{equation*}
c^{3n} - c^{3 \left( n + 1 \right)}.
\end{equation*}%
%
where $c \in (0, 1)$ is the distance along $r_\mathrm{max}$ to map the radial splits to.
Thus, the ratio of the volume between shell $n$ and $n+1$ is

\begin{equation*}
\frac{ c^{3n} - c^{3 \left( n + 1 \right)} }{ c^{3 \left(n + 1 \right)} - c^{3\left( n + 2 \right)} } = \frac{ c^{3n} \left( 1 - c^{3} \right) }{ c^{3} c^{3n} \left( 1 - c^{3} \right) } = \frac{1}{c^{3}}.
\end{equation*}%
%
Equating this to the desired ratio of volumes, we get

\begin{equation*}
\frac{1}{c^3} = {f^3}, \quad c = \frac{1}{f}.
\end{equation*}

From this, we conclude that radii at powers of $c$ should be mapped to powers of $1/2$; radii that are in between are linearly interpolated.
We first calculate the physical shell that contains the radius, which is simply $s = \lfloor \log_c \hat{r} \rfloor$.
The shell is then used to find the (normalized) minimum and maximum radius of the shell in both physical and grid space.
We refer to these as $\ell$ and $u$, respectively, with subscripts $g$ for grid space and $p$ for physical.
These are given by

\begin{equation*}
\ell_p = c^{s+1}, \quad u_p = c^s, \quad \ell_g = 0.5^{s+1}, \quad \text{and} \quad u_g = 0.5^s.
\end{equation*}

The full mapping is thus

\begin{equation*}
m(\hat{r}) = du_g + (1-d)\ell_g, \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{ \hat{r} - \ell_p}{u_p - \ell_p}.
\end{equation*}
%
For the inverse, we have

\begin{equation*}
m^{-1}(\hat{r}) = du_p + (1-d)\ell_p, \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{ \hat{r} - \ell_g}{u_g - \ell_g}.
\end{equation*}
%
For the inverse, shell $s$ would be carried forward from the layer parameterization (Section~\ref{sec:encoding:param}), however it can also be calculated independently with $s = \lfloor \log_{0.5} \hat{r} \rfloor$.

The results of this mapping are shown in Figure~\ref{fig:proj-grids} left.
Note that for a 1:4 surface refinement factor, $c = 1/2$, which means this mapping is equivalent to the identity.
In the case where only regular prismatoid refinement is used, this mapping is also equivalent to the identity.


This mapping---and the subsequent ones---have the side effect of changing the aspect ratio of cells in grid space as compared to the corresponding cells in physical space.
This means that when determining the refinement parameters needed to achieve the desired aspect ratio, the cells in physical space should be considered as opposed to grid space, as done in Section~\ref{sec:grid:ar}.
This is easily addressed by changing the value of $\upsilon$ used in Equations~\ref{eq:extraSplits} and \ref{eq:num2D} to be $(1 - c)$.


%\paragraph{Volume preserving mapping}
While the above mapping preserves volume between shells of the grid, cells within a given shell will still have varying volumes.
This is due to the volume of cells growing cubically with respect to radius.
To accommodate this, we replace the linear interpolation of the above mapping with one that maps changes in volume in physical space to linear distance in grid space, the result of which is

\begin{equation*}
m(\hat{r}) = du_g + (1-d)\ell_g, \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{ \hat{r}^3 - \ell_p^3} {u_p^3 - \ell_p^3}.
\end{equation*}
%
Likewise, the inverse is given by

\begin{equation*}
m^{-1}(\hat{r}) = \sqrt[3]{ d u_p^{3} + \left( 1 - d \right) \ell_p^{3} }, \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{\hat{r} - \ell_g}{u_g - \ell_g}.
\end{equation*}
%
With this mapping, cells in the same layer will have perfect volume preservation assuming the input DGGS is \textit{area} preserving.
Depending on the layering sequence, however, volume will not necessarily be preserved between cells in different shells.
Additionally, the centre layer will never have volume preservation with the other layers.
The results of this mapping are shown in Figure~\ref{fig:proj-grids} right.
As can be seen, cells in each shell are stretched and squashed in order to ensure they have equal volume.


%\paragraph{Balanced mapping}
While volume preservation is an important property for certain applications, it may also be desirable to avoid the stretching and squashing noted above.
To accommodate different balances of volume preservation and cell compactness, we use a mapping that blends between the results of the first and second proposed mappings.
Mapping one uses linear interpolation, and results in cells with equal radial extent; mapping two uses a cubic interpolation and results in cells with equal volume.
Using a different power, $t$, between one and three will result in a blending between these two properties.
A result using $t=2$ is shown in Figure~\ref{fig:proj-grids} centre.


\section{Latitude Mappings for SDOG}

%\section{Mapping Modified SDOG Grids} \label{sec:mapping}
By modifying the splitting surfaces used for subdivision, any SDOG indexing operations that depend on the location of cells in the grid will no longer function properly.
Examples of these operations include point to cell queries, which give the cell that contains a given point, and index inversion, which calculates the location and geometry of a cell from its index.
The obvious solution is to simply redefine these operations on the new geometry, however, this is not necessarily practical as it would have to be done individually for each modified grid.
Additionally, the more complex geometry of the modified grids may make these algorithms more difficult to design and/or more computationally expensive to perform as compared to the ones for conventional SDOG.
A better solution is to find a mapping (and corresponding inverse mapping) between a conventional SDOG grid and the grid resulting from the modified subdivision scheme.
Given this mapping, all indexing operations can be done using the standard algorithms, with inputs and outputs converted between the conventional SDOG grid and the modified one accordingly.


For the stationary subdivision schemes this mapping is straightforward.
Since only the latitudinal splitting surface of SG cells is modified, latitudes in the range $[0, \pm\frac{\pi}{4})$ should be mapped to the range $[0, \pm\alpha_{\varphi}^{SG} \frac{\pi}{2})$ and likewise the range $[\pm\frac{\pi}{4}, \pm\frac{\pi}{2}]$ to the range $[\pm\alpha_{\varphi}^{SG} \frac{\pi}{2}, \pm\frac{\pi}{2}]$.
This can be done with a simple linear map, and the inverse follows trivially.


For the non-stationary schemes this mapping is more complicated.
We wish to define a function $M \colon (\varphi, r) \rightarrow (\varphi, r)$ that converts a latitude and radius in a conventional SDOG grid to the corresponding latitude and radius in the modified grid (longitude does not need to be mapped, as it is not changed between the two grids).
The two coordinates act independently of each other, so we can split this function into its two components, $M_{\varphi}(\varphi)$ and $M_{r}(r)$, and derive each one and its inverse individually.
This is done by parameterizing points inside an NG cell using the function(s) used to calculate its splitting surfaces (Eq.~(\ref{eq:convex}) for conventional SDOG and Eq.~(\ref{eq:radVol}) and (\ref{eq:latVol}) for the modified grid).
NG cells are used for this purpose as all children cells are also NG, and therefore use the same formulations for calculating splitting surfaces.
By finding the boundaries of the coarsest NG cell that contains a given point, these parameterizations can be used to go from one space to the other by finding a relationship between them---in this case $d = \alpha = p$---all of which can be done in constant time.
The final formulations are as follows, with the full derivation found in Appendix \ref{app:map}.
Let $R_m$ be the radius of the grid.
Latitude forward:
%
\begin{equation*}
M_{\varphi}(\varphi) = \sin^{-1} \left( d u_{v} + \left( 1 - d \right) \ell_{v} \right), \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{\frac{2\varphi}{\pi} - \ell_{c}}{u_{c} - \ell_{c}},
\end{equation*}
%
\begin{equation*}
u_{c} = 1 - \left( \frac{1}{2} \right)^{ \left\lceil \log_{0.5} \left( 1 - \frac{2\varphi}{\pi} \right) \right\rceil }, \quad u_{v} = 2 u_{c} - u_{c}^{2}.
\end{equation*}
%
\begin{equation*}
\ell_{c} = 1 - \left( \frac{1}{2} \right)^{ \left\lfloor \log_{0.5} \left( 1 - \frac{2\varphi}{\pi} \right) \right\rfloor }, \quad \text{and} \quad \ell_{v} = 2 \ell_{c} - \ell_{c}^{2}.
\end{equation*}
%
%
Radius forward:
%
\begin{equation*}
M_{r}(r) = R_{m} \sqrt[3]{ d u^{3} + \left( 1 - d \right) \ell^{3} }, \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{\frac{r}{R_{m}} - \ell}{u - \ell},
\end{equation*}
%
\begin{equation*}
u = \left( \frac{1}{2} \right)^{ \left\lfloor \log_{0.5} \left( \frac{r}{R_{m}} \right) \right\rfloor }, \quad \text{and} \quad
\end{equation*}
%
\begin{equation*}
\ell = \left( \frac{1}{2} \right)^{ \left\lceil \log_{0.5} \left( \frac{r}{R_{m}} \right) \right\rceil }.
\end{equation*}
%
%
Latitude inverse:
%
\begin{equation*}
M^{-1}_{\varphi}(\varphi) = \frac{\pi}{2} \left( d u_{c} + \left( 1 - d \right) \ell_{c} \right), \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{\sin \varphi - \ell_{v}}{u_{v} - \ell_{v}},
\end{equation*}
%
\begin{equation*}
u_{c} = 1 - \left( \frac{1}{2} \right)^{ \left\lceil \log_{0.5} \left( \sqrt{1 - \sin \varphi} \right) \right\rceil },
\end{equation*}
%
\begin{equation*}
\ell_{c} = 1 - \left( \frac{1}{2} \right)^{ \left\lfloor \log_{0.5} \left( \sqrt{1 - \sin \varphi} \right) \right\rfloor },
\end{equation*}
%
%
and both $u_{v}$ and $\ell_{v}$ follow the same as the forward.
Radius inverse:
%
\begin{equation*}
M^{-1}_{r}(r) = R_m \left( d u + \left( 1 - d \right) \ell \right), \quad \text{where}
\end{equation*}
%
\begin{equation*}
d = \frac{ \left( \frac{r}{R_{m}} \right)^{3} - \ell^{3}}{u^{3} - \ell^{3}}
\end{equation*}
%
and both $u$ and $\ell$ follow the same as the forward.


In the case where a division by zero occurs, (i.e. when $u = \ell$ or $u_{c} = \ell_{c}$), the result of said division is treated as zero.
The latitude mappings assume $\varphi \ge 0$, however, from symmetry a negative value of $\varphi$ can easily be accommodated by using the absolute value and negating the final result.
This mapping is applicable to the first non-stationary scheme discussed in Section \ref{sec:method-nonStationary}; schemes derived from Eq.~(\ref{eq:beta}) cannot be mapped, as this formulation cannot easily be expressed in terms of a parameter.
In the future, other blending methods may be explored that allow for a similar mapping to be derived.




\section{Summary}